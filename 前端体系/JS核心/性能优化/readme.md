# 前端性能优化

性能优化一直是老生常谈的问题，平时我们可能用到的都是非常琐碎的知识来优化。

这节会具体的谈到每一方面。

## 从一道题目开始

**从浏览器输入url到页面展示具体发生了什么?**

非常耳熟的一道题目，不过仔细一想，其实它要考察的东西还真不少，比如DNS查询 TCP连接 http请求 浏览器渲染等等。

这里我们不讨论非常底层的网络传输协议，仅对我们比较常见的知识点就行解析。

那我们回答以下这道题目。

浏览器输入url到页面展示发生了:

- DNS查询：将输入的域名转换成IP地址
- TCP连接：一个网络请求过程必定会经历三次握手四次挥手的过程
- HTTP请求: 浏览器将请求内容传输给服务器，服务器将响应内容发送给浏览器
- 浏览器渲染：浏览器将服务器返回的html解析成一个个像素点展示在电脑上。

上面的每一步其实又可以分为很多内容。比如:

DNS查询：DNS的查询策略是什么? 

TCP连接：如何减少TCP挥手带来的损耗? 

HTTP请求: 是不是考虑压缩请求内容，是不是对多个资源进行合并来减少请求数量? 

浏览器渲染: 浏览器是如何渲染的呢? css js阻塞是怎么一回事? 为什么DOM操作非常费性能? 重绘 重排是怎么一回事? 

上面已经提出了很多的疑问? 其实这也是本节内容要写的内容。所以篇幅会比较长。

## 如何优化DNS查询:

### DNS查询:

首先我们说以下DNS查询策略：

我们都知道DNS查询的作用是: 将域名转换成ip

这里有些人就说了: 那我们直接用ip访问不就好了吗? 跳过了DNS查询过程。

话糙理不糙，确实是这样的。

那为什么没有广泛使用呢?

首先是ip都是数字，记不住，第二，现在web应用比较庞大，有时一台服务器无法满足，所以有很多服务器在同时运行，这里就需要有一个概念了"负载均衡""反向代理"，因为我们无法得知真正为我们提供服务的是哪个服务器，所以直接访问ip比较少。

上面扯了半天废话，下面来说下查询策略:(以查询www.xxx.com为例)

1. 从浏览器缓存寻找，浏览器会定期缓存DNS记录(chrome下使用chrome://net-internals/#dns查看)

2. 如果浏览器缓存中没有找到，从操作系统缓存种需按照(windows下cmd下可使用 ipconfig /displaydns 命令查看)

3. 如果操作系统缓存中没有找到，在路由器缓存中寻找(路由器也可以缓存)

4. 如果未找到，寻找本地hosts文件(windows C:\WINDOWS\system32\drivers\etc\hosts，本地hosts文件可以配置ip和域名的对应关系，所以如果本机的hosts配置了这个映射关系，就会使用hosts里的ip地址
)

    比如hosts文件修改为：
    ```
        www.xxx.com 127.0.0.1
    ```
    
    如果本地启动了一个127.0.0.1 80端口的服务，访问www.xxx.com则页面会返回本地服务配置的页面信息

5. 如果还未找到，向运营商查询。运营商一般都有DNS服务器来应对DNS请求，而且运营商也会缓存这个映射记录。所以，首先向运营商的缓存查询。
6. 如果运营商的缓存中未找到，则运营商的DNS服务器就会工作,向域服务器查询，首先会向根域服务器查询(.是根域服务器)，如果没有查找到，向.com域服务器查询，如果还未查到，向xxx.com域服务器查询，如果还未找到，向www.xxx.com查询，查到就停止。

    > 这里有个小知识点:域名是从右向左解析的，可不是按照我们书写解析的！

上面我们大概了说了以下域名的查找策略，其实DNS查找比较复杂，这里我们只要知道它是这么查找就够了。

前端优化DNS方式主要是dns-prefetch(DNS预查询)

```
<meta http-equiv="x-dns-prefetch-control" content="on">

<link rel="dns-prefetch" href="http://www.xxx.com">

```
通过预查询会加快DNS查找速度。

### CDN加速

什么是CDN?

比如我的服务器在北京，那国外的人访问服务器的时候，就会非常慢，因为距离非常远，这和我们平时访问一些英文网站一样，距离远必然会慢。 那我再国外又部署了几台服务器，那国外的人访问服务器会访问到国外的那几台服务器，距离近了，速度自然就快了。

这里我们不谈CDN的工作原理,因为笔者也没搞清楚。

cdn的应用:

cdn适合放置静态资源，比如js css video img 等等。


## TCP如何优化

我们知道TCP会有握手挥手的消耗问题。(具体TCP三次握手四次挥手会写一片单独的文章)

那如何改善这个问题呢?

在http1.0时代，当一个http请求结束就会关闭当前连接，这就造成了TCP连接的浪费。

所以在http1.1时代，http默认会携带Connection: keep-alive, 主要是为了保持这个通信通道，并且复用。

比如请求完一个文件后，保持通道，下一个请求依然在这通道上通信。

在http1.1中还增加了pipelining,那什么是pipelining?

> pipelining: 就是支持多个请求同时进行，但是返回顺序依然按照请求顺序依次返回

这就是"线头阻塞"

虽然说，保证了请求可以同时进行，但是返回顺序按照请求顺序依次返回。

但是注意: 这个功能默认在浏览器内是关闭的。

在http1.1中，单个 TCP 连接在同一时刻只能处理一个请求。(不开启pipelining情况下)

所以一般而言，**浏览器都是开启多个TCP通道来支持http请求的。**

那是不是浏览器对于同一个域名支持开启的TCP数量是不限的呢？(这里说的是同时，也就是浏览器同时开启的TCP数量)

不是，chrome是6个，其他浏览器(包含手机浏览器)最大并发数也就6-10个。

说了这么多，那我们到底如何优化?

**使用http2优化**

上面我们说了很多http1.1的问题(虽然在http1.0基础上优化很大)，比如线头阻塞 http头信息重复(其实我们发现我们每次请求头信息基本有很多相同的)

这里我们只提到http2的一点点特性: 头部压缩 多路复用

其实http2还有很多特性，因为内容偏多，这里就不展开说了。以后会有单独的一片http2的文章。

- 多路并用：支持一个TCP通道多个http请求同时请求，不会像pipelining一样，返回顺序由文件大小决定。大文件自然相对慢一点，但是不会受到请求顺序的影响。

- 头部压缩: 就是字面意思，压缩http头信息

下面有个网站https://http2.akamai.com/demo,可以感受以下http和http2的区别。

这是chrome下对上面网站的请求情况：

http请求： 

![http请求](./img/http请求.jpg)

上面我们发现上面有个ConnectionID，其实我们可以近似认为每个ConnectionID就是一个TCP连接。

为了证明上面提到的"同一个TCP通道http请求顺序执行"的结论，大家可以点以下"ConnectionID",这是用于排序的.

![http请求](./img/http_排序.jpg)

鼠标移动到Waterfall那一列，指向一个img资源，可以看到它的排队时间和开始时间。

那http2是如何请求的呢?

![http2请求](./img/http2.jpg)

鼠标移动到Waterfall那一列，指向任意一个img资源，可以看到开始时间都是相同的，返回也是不受限制的。

http2在国内还是应用比较少，如果有机会，可尝试来用http2。






